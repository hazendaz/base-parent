<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TestKeyGen.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fileupload</a> &gt; <a href="index.source.html" class="el_package">com.hazendaz.encryption</a> &gt; <span class="el_source">TestKeyGen.java</span></div><h1>TestKeyGen.java</h1><pre class="source lang-java linenums">package com.hazendaz.encryption;

import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Security;
import java.util.Date;

import javax.crypto.Cipher;
import javax.inject.Inject;

import org.bouncycastle.bcpg.CompressionAlgorithmTags;
import org.bouncycastle.bcpg.HashAlgorithmTags;
import org.bouncycastle.bcpg.PublicKeyAlgorithmTags;
import org.bouncycastle.bcpg.SymmetricKeyAlgorithmTags;
import org.bouncycastle.bcpg.sig.Features;
import org.bouncycastle.bcpg.sig.KeyFlags;
import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
import org.bouncycastle.crypto.generators.RSAKeyPairGenerator;
import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
import org.bouncycastle.crypto.params.RSAKeyGenerationParameters;
import org.bouncycastle.crypto.util.PrivateKeyFactory;
import org.bouncycastle.crypto.util.PublicKeyFactory;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openpgp.PGPException;
import org.bouncycastle.openpgp.PGPKeyPair;
import org.bouncycastle.openpgp.PGPKeyRingGenerator;
import org.bouncycastle.openpgp.PGPPublicKeyRing;
import org.bouncycastle.openpgp.PGPSecretKeyRing;
import org.bouncycastle.openpgp.PGPSignature;
import org.bouncycastle.openpgp.PGPSignatureSubpacketGenerator;
import org.bouncycastle.openpgp.operator.PBESecretKeyEncryptor;
import org.bouncycastle.openpgp.operator.PGPDigestCalculator;
import org.bouncycastle.openpgp.operator.bc.BcPBESecretKeyEncryptorBuilder;
import org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;
import org.bouncycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider;
import org.bouncycastle.openpgp.operator.bc.BcPGPKeyPair;
import org.slf4j.Logger;

<span class="nc" id="L42">public class TestKeyGen {</span>

    public final static PGPKeyRingGenerator generateKeyRingGenerator(final String id, final char[] pass,
            final int s2kcount) throws Exception {
        // This object generates individual key-pairs.
<span class="nc" id="L47">        final RSAKeyPairGenerator kpg = new RSAKeyPairGenerator();</span>

        // Boilerplate RSA parameters, no need to change anything
        // except for the RSA key-size (2048). You can use whatever
        // key-size makes sense for you -- 4096, etc.
<span class="nc" id="L52">        kpg.init(new RSAKeyGenerationParameters(BigInteger.valueOf(0x10001), new SecureRandom(), 2048, 12));</span>

        // First create the master (signing) key with the generator.
<span class="nc" id="L55">        final PGPKeyPair rsakp_sign = new BcPGPKeyPair(PublicKeyAlgorithmTags.RSA_SIGN, kpg.generateKeyPair(),</span>
                new Date());
        // Then an encryption subkey.
<span class="nc" id="L58">        final PGPKeyPair rsakp_enc = new BcPGPKeyPair(PublicKeyAlgorithmTags.RSA_ENCRYPT, kpg.generateKeyPair(),</span>
                new Date());

        // Add a self-signature on the id
<span class="nc" id="L62">        final PGPSignatureSubpacketGenerator signhashgen = new PGPSignatureSubpacketGenerator();</span>

        // Add signed metadata on the signature.
        // 1) Declare its purpose
<span class="nc" id="L66">        signhashgen.setKeyFlags(false, KeyFlags.SIGN_DATA | KeyFlags.CERTIFY_OTHER);</span>
        // 2) Set preferences for secondary crypto algorithms to use
        // when sending messages to this key.
<span class="nc" id="L69">        signhashgen.setPreferredSymmetricAlgorithms(false, new int[] { SymmetricKeyAlgorithmTags.AES_256,</span>
                SymmetricKeyAlgorithmTags.AES_192, SymmetricKeyAlgorithmTags.AES_128 });
<span class="nc" id="L71">        signhashgen.setPreferredHashAlgorithms(false, new int[] { HashAlgorithmTags.SHA256, HashAlgorithmTags.SHA1,</span>
                HashAlgorithmTags.SHA384, HashAlgorithmTags.SHA512, HashAlgorithmTags.SHA224, });
        // 3) Request senders add additional checksums to the
        // message (useful when verifying unsigned messages.)
<span class="nc" id="L75">        signhashgen.setFeature(false, Features.FEATURE_MODIFICATION_DETECTION);</span>

        // Create a signature on the encryption subkey.
<span class="nc" id="L78">        final PGPSignatureSubpacketGenerator enchashgen = new PGPSignatureSubpacketGenerator();</span>
        // Add metadata to declare its purpose
<span class="nc" id="L80">        enchashgen.setKeyFlags(false, KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE);</span>

        // Objects used to encrypt the secret key.
<span class="nc" id="L83">        final PGPDigestCalculator sha1Calc = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA1);</span>
<span class="nc" id="L84">        final PGPDigestCalculator sha256Calc = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA256);</span>

        // bcpg 1.48 exposes this API that includes s2kcount. Earlier
        // versions use a default of 0x60.
<span class="nc" id="L88">        final PBESecretKeyEncryptor pske = new BcPBESecretKeyEncryptorBuilder(SymmetricKeyAlgorithmTags.AES_256,</span>
<span class="nc" id="L89">                sha256Calc, s2kcount).build(pass);</span>

        // Finally, create the keyring itself. The constructor
        // takes parameters that allow it to generate the self
        // signature.
<span class="nc" id="L94">        final PGPKeyRingGenerator keyRingGen = new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION, rsakp_sign,</span>
<span class="nc" id="L95">                id, sha1Calc, signhashgen.generate(), null, new BcPGPContentSignerBuilder(rsakp_sign.getPublicKey()</span>
<span class="nc" id="L96">                        .getAlgorithm(), HashAlgorithmTags.SHA1), pske);</span>

        // Add our encryption subkey, together with its signature.
<span class="nc" id="L99">        keyRingGen.addSubKey(rsakp_enc, enchashgen.generate(), null);</span>
<span class="nc" id="L100">        return keyRingGen;</span>
    }

    public static void main(final String[] args) {

<span class="nc" id="L105">        final TestKeyGen testKeyGen = new TestKeyGen();</span>

<span class="nc" id="L107">        final char password[] = { 't', 'e', 's', 't', 'm', 'e' };</span>
<span class="nc" id="L108">        Security.addProvider(new BouncyCastleProvider());</span>
<span class="nc" id="L109">        testKeyGen.logger.info(testKeyGen.createSecretKey(&quot;jeremylandis@hotmail.com&quot;, password).toString());</span>
<span class="nc" id="L110">        testKeyGen.logger.info(testKeyGen.createPublicKey(&quot;jeremylandis@hotmail.com&quot;, password).toString());</span>
<span class="nc" id="L111">    }</span>

    @Inject
    private Logger logger;

    public PGPPublicKeyRing createPublicKey(final String email, final char[] password) {

        // Checks for max allowed value --- without fix in Java, it should say
        // 128.
        try {
<span class="nc" id="L121">            final int maxKeyLen = Cipher.getMaxAllowedKeyLength(&quot;AES&quot;);</span>
<span class="nc" id="L122">            this.logger.info(&quot;Allowed Key Length is: {}&quot;, String.valueOf(maxKeyLen));</span>
<span class="nc" id="L123">        } catch (final NoSuchAlgorithmException e1) {</span>
<span class="nc" id="L124">            this.logger.error(e1.toString());</span>
<span class="nc" id="L125">        }</span>

<span class="nc" id="L127">        KeyPair keyPair = null;</span>
<span class="nc" id="L128">        KeyPair keyPair2 = null;</span>
<span class="nc" id="L129">        PGPPublicKeyRing pkr = null;</span>
        try {

<span class="nc" id="L132">            final KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;, &quot;BC&quot;);</span>
<span class="nc" id="L133">            keyPairGen.initialize(4096);</span>

<span class="nc" id="L135">            keyPair = keyPairGen.generateKeyPair();</span>
<span class="nc" id="L136">            keyPair2 = keyPairGen.generateKeyPair();</span>

<span class="nc" id="L138">            final AsymmetricKeyParameter privKey = PrivateKeyFactory.createKey(keyPair.getPrivate().getEncoded());</span>
<span class="nc" id="L139">            final AsymmetricKeyParameter pubKey = PublicKeyFactory.createKey(keyPair2.getPublic().getEncoded());</span>
<span class="nc" id="L140">            final AsymmetricCipherKeyPair privKeyParams = new AsymmetricCipherKeyPair(pubKey, privKey);</span>

<span class="nc" id="L142">            final PGPSignatureSubpacketGenerator hashedGen = new PGPSignatureSubpacketGenerator();</span>

<span class="nc" id="L144">            hashedGen.setKeyFlags(true, KeyFlags.CERTIFY_OTHER | KeyFlags.SIGN_DATA | KeyFlags.ENCRYPT_COMMS</span>
                    | KeyFlags.ENCRYPT_STORAGE);

<span class="nc" id="L147">            hashedGen.setPreferredCompressionAlgorithms(false, new int[] { CompressionAlgorithmTags.ZIP });</span>

<span class="nc" id="L149">            hashedGen.setPreferredHashAlgorithms(false, new int[] { HashAlgorithmTags.SHA1 });</span>

<span class="nc" id="L151">            hashedGen.setPreferredSymmetricAlgorithms(false, new int[] { SymmetricKeyAlgorithmTags.AES_128 });</span>

<span class="nc" id="L153">            final PGPKeyPair secretKey2 = new BcPGPKeyPair(PublicKeyAlgorithmTags.RSA_GENERAL, privKeyParams,</span>
                    new Date());

<span class="nc" id="L156">            final PGPKeyRingGenerator keyRingGen = TestKeyGen.generateKeyRingGenerator(email + &quot;&lt;&quot; + email</span>
                    + &quot;@homail.com&gt;&quot;, password, 0xc0);

<span class="nc" id="L159">            keyRingGen.addSubKey(secretKey2);</span>

<span class="nc" id="L161">            pkr = keyRingGen.generatePublicKeyRing();</span>

<span class="nc" id="L163">        } catch (final PGPException e) {</span>
<span class="nc" id="L164">            this.logger.error(e.toString());</span>
<span class="nc" id="L165">            this.logger.error(e.getUnderlyingException().toString());</span>
<span class="nc" id="L166">        } catch (final Exception e) {</span>
<span class="nc" id="L167">            this.logger.error(e.toString());</span>
<span class="nc" id="L168">        }</span>
<span class="nc" id="L169">        return pkr;</span>

    }

    // Note: s2kcount is a number between 0 and 0xff that controls the
    // number of times to iterate the password hash before use. More
    // iterations are useful against offline attacks, as it takes more
    // time to check each password. The actual number of iterations is
    // rather complex, and also depends on the hash function in use.
    // Refer to Section 3.7.1.3 in rfc4880.txt. Bigger numbers give
    // you more iterations. As a rough rule of thumb, when using
    // SHA256 as the hashing function, 0x10 gives you about 64
    // iterations, 0x20 about 128, 0x30 about 256 and so on till 0xf0,
    // or about 1 million iterations. The maximum you can go to is
    // 0xff, or about 2 million iterations. I'll use 0xc0 as a
    // default -- about 130,000 iterations.

    public PGPSecretKeyRing createSecretKey(final String email, final char[] password) {

        // Checks for max allowed value --- without fix in Java, it should say
        // 128.
        try {
<span class="nc" id="L191">            final int maxKeyLen = Cipher.getMaxAllowedKeyLength(&quot;AES&quot;);</span>
<span class="nc" id="L192">            this.logger.info(&quot;Allowed Key Length is: {}&quot;, String.valueOf(maxKeyLen));</span>
<span class="nc" id="L193">        } catch (final NoSuchAlgorithmException e1) {</span>
<span class="nc" id="L194">            this.logger.error(e1.toString());</span>
<span class="nc" id="L195">        }</span>

<span class="nc" id="L197">        KeyPair keyPair = null;</span>
<span class="nc" id="L198">        KeyPair keyPair2 = null;</span>
<span class="nc" id="L199">        PGPSecretKeyRing skr = null;</span>
        try {

<span class="nc" id="L202">            final KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;, &quot;BC&quot;);</span>
<span class="nc" id="L203">            keyPairGen.initialize(4096);</span>

<span class="nc" id="L205">            keyPair = keyPairGen.generateKeyPair();</span>
<span class="nc" id="L206">            keyPair2 = keyPairGen.generateKeyPair();</span>

<span class="nc" id="L208">            final AsymmetricKeyParameter privKey = PrivateKeyFactory.createKey(keyPair.getPrivate().getEncoded());</span>
<span class="nc" id="L209">            final AsymmetricKeyParameter pubKey = PublicKeyFactory.createKey(keyPair2.getPublic().getEncoded());</span>
<span class="nc" id="L210">            final AsymmetricCipherKeyPair privKeyParams = new AsymmetricCipherKeyPair(pubKey, privKey);</span>

<span class="nc" id="L212">            final PGPSignatureSubpacketGenerator hashedGen = new PGPSignatureSubpacketGenerator();</span>

<span class="nc" id="L214">            hashedGen.setKeyFlags(true, KeyFlags.CERTIFY_OTHER | KeyFlags.SIGN_DATA | KeyFlags.ENCRYPT_COMMS</span>
                    | KeyFlags.ENCRYPT_STORAGE);

<span class="nc" id="L217">            hashedGen.setPreferredCompressionAlgorithms(false, new int[] { CompressionAlgorithmTags.ZIP });</span>

<span class="nc" id="L219">            hashedGen.setPreferredHashAlgorithms(false, new int[] { HashAlgorithmTags.SHA1 });</span>

<span class="nc" id="L221">            hashedGen.setPreferredSymmetricAlgorithms(false, new int[] { SymmetricKeyAlgorithmTags.AES_128 });</span>

<span class="nc" id="L223">            final PGPKeyPair secretKey2 = new BcPGPKeyPair(PublicKeyAlgorithmTags.RSA_GENERAL, privKeyParams,</span>
                    new Date());

<span class="nc" id="L226">            final PGPKeyRingGenerator keyRingGen = TestKeyGen.generateKeyRingGenerator(email + &quot;&lt;&quot; + email</span>
                    + &quot;@homail.com&gt;&quot;, password, 0xc0);

<span class="nc" id="L229">            keyRingGen.addSubKey(secretKey2);</span>

<span class="nc" id="L231">            skr = keyRingGen.generateSecretKeyRing();</span>

<span class="nc" id="L233">        } catch (final PGPException e) {</span>
<span class="nc" id="L234">            this.logger.error(e.toString());</span>
<span class="nc" id="L235">            this.logger.error(e.getUnderlyingException().toString());</span>
<span class="nc" id="L236">        } catch (final Exception e) {</span>
<span class="nc" id="L237">            this.logger.error(e.toString());</span>
<span class="nc" id="L238">        }</span>
<span class="nc" id="L239">        return skr;</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>